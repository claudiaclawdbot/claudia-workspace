/**
 * Revenue Tracker
 * 
 * Tracks revenue generated by the analytics dashboard itself.
 * Monitors payments for premium features.
 */

export class RevenueTracker {
  constructor(store) {
    this.store = store;
    this.payments = [];
    this.dailyRevenue = new Map();
  }
  
  /**
   * Record a payment for analytics access
   */
  recordPayment({ type, amount, from, timestamp }) {
    const payment = {
      id: `payment-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`,
      type,
      amount,
      from,
      timestamp,
      recordedAt: new Date().toISOString()
    };
    
    this.payments.push(payment);
    
    // Update daily revenue
    const day = timestamp.substring(0, 10);
    if (!this.dailyRevenue.has(day)) {
      this.dailyRevenue.set(day, {
        day,
        total: 0,
        byType: {}
      });
    }
    
    const dayStats = this.dailyRevenue.get(day);
    const amountNum = parseFloat(amount) / 1000000; // Convert from 6 decimals to USDC
    dayStats.total += amountNum;
    
    if (!dayStats.byType[type]) {
      dayStats.byType[type] = 0;
    }
    dayStats.byType[type] += amountNum;
    
    return payment;
  }
  
  /**
   * Get total revenue statistics
   */
  getRevenue() {
    const total = this.payments.reduce((sum, p) => {
      return sum + (parseFloat(p.amount) / 1000000);
    }, 0);
    
    const byTier = this.payments.reduce((acc, p) => {
      const amount = parseFloat(p.amount) / 1000000;
      acc[p.type] = (acc[p.type] || 0) + amount;
      return acc;
    }, {});
    
    const byDay = Array.from(this.dailyRevenue.values())
      .map(d => ({
        day: d.day,
        total: d.total.toFixed(6),
        byType: d.byType
      }))
      .sort((a, b) => a.day.localeCompare(b.day));
    
    // Calculate this month vs last month
    const now = new Date();
    const thisMonthKey = `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
    const lastMonthDate = new Date(now.getFullYear(), now.getMonth() - 1, 1);
    const lastMonthKey = `${lastMonthDate.getFullYear()}-${String(lastMonthDate.getMonth() + 1).padStart(2, '0')}`;
    
    const thisMonth = this.payments
      .filter(p => p.timestamp.startsWith(thisMonthKey))
      .reduce((sum, p) => sum + (parseFloat(p.amount) / 1000000), 0);
    
    const lastMonth = this.payments
      .filter(p => p.timestamp.startsWith(lastMonthKey))
      .reduce((sum, p) => sum + (parseFloat(p.amount) / 1000000), 0);
    
    return {
      total: total.toFixed(6),
      byTier,
      byDay,
      thisMonth: thisMonth.toFixed(6),
      lastMonth: lastMonth.toFixed(6),
      paymentCount: this.payments.length,
      avgPayment: this.payments.length > 0 ? (total / this.payments.length).toFixed(6) : '0'
    };
  }
  
  /**
   * Get revenue projection based on current trend
   */
  getProjection(days = 30) {
    const recentDays = Array.from(this.dailyRevenue.values())
      .slice(-7);
    
    if (recentDays.length === 0) {
      return { projected: '0', confidence: 'low' };
    }
    
    const avgDaily = recentDays.reduce((sum, d) => sum + d.total, 0) / recentDays.length;
    const projected = avgDaily * days;
    
    return {
      projected: projected.toFixed(6),
      dailyAverage: avgDaily.toFixed(6),
      confidence: recentDays.length >= 7 ? 'medium' : 'low',
      basedOnDays: recentDays.length
    };
  }
  
  /**
   * Get recent payments
   */
  getRecentPayments(limit = 10) {
    return this.payments
      .slice(-limit)
      .reverse()
      .map(p => ({
        id: p.id,
        type: p.type,
        amount: (parseFloat(p.amount) / 1000000).toFixed(6),
        from: p.from,
        timestamp: p.timestamp
      }));
  }
}
