#!/usr/bin/env bash
#===============================================================================
#
#          FILE: name-violation-check.sh
#
#         USAGE: ./name-violation-check.sh [--report] [--fix]
#
#   DESCRIPTION: Automated check for name/policy violations in codebase
#                Scans all files for forbidden terms and patterns
#
#       OPTIONS: --report    Generate detailed report (default: quick check)
#                --fix       Attempt automatic fixes (use with caution)
#
#  REQUIREMENTS: grep, find, git
#
#        AUTHOR: Claudia (claudiaclawdbot)
#       VERSION: 1.0.0
#       CREATED: 2026-02-04
#===============================================================================

# Strict mode
set -euo pipefail
IFS=$'\n\t'

# Configuration
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REPO_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"
SCRIPT_NAME="$(basename "${BASH_SOURCE[0]}")"
ALERTS_DIR="${REPO_ROOT}/memory/alerts"
DATE=$(date +%Y-%m-%d)
REPORT_FILE="${ALERTS_DIR}/name-violations-${DATE}.md"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

# Logging
log_info() { echo -e "${BLUE}[INFO]${NC} $*"; }
log_warn() { echo -e "${YELLOW}[WARN]${NC} $*"; }
log_error() { echo -e "${RED}[ERROR]${NC} $*"; }
log_success() { echo -e "${GREEN}[OK]${NC} $*"; }

# Forbidden patterns (add more as needed)
# Format: "pattern|description"
FORBIDDEN_PATTERNS=(
    "ryan|Real name usage"
    "james|Real name usage"
    "ryan@|Email with real name"
    "james@|Email with real name"
)

# Directories to exclude
EXCLUDE_DIRS=(
    ".git"
    "node_modules"
    "archive"
    ".openclaw"
)

# File types to check
INCLUDE_EXTENSIONS=(
    "md"
    "txt"
    "js"
    "ts"
    "sh"
    "json"
    "html"
    "css"
    "yml"
    "yaml"
)

# Build exclude arguments for find
build_exclude_args() {
    local args=""
    for dir in "${EXCLUDE_DIRS[@]}"; do
        args="${args} -not -path \"*/${dir}/*\""
    done
    echo "$args"
}

# Build include arguments for find
build_include_args() {
    local args=""
    for ext in "${INCLUDE_EXTENSIONS[@]}"; do
        if [[ -n "$args" ]]; then
            args="${args} -o"
        fi
        args="${args} -name '*.${ext}'"
    done
    echo "$args"
}

# Check single file for violations
check_file() {
    local file="$1"
    local violations=()
    
    for pattern_info in "${FORBIDDEN_PATTERNS[@]}"; do
        local pattern="${pattern_info%%|*}"
        local description="${pattern_info##*|}"
        
        if grep -i "$pattern" "$file" >/dev/null 2>&1; then
            local lines
            lines=$(grep -in "$pattern" "$file" | head -3)
            violations+=("${description}:\n${lines}")
        fi
    done
    
    if [[ ${#violations[@]} -gt 0 ]]; then
        printf '%s\n' "${violations[@]}"
        return 1
    fi
    return 0
}

# Generate report
generate_report() {
    local total_violations=0
    local files_with_violations=()
    
    mkdir -p "$ALERTS_DIR"
    
    {
        echo "# Name Violation Report - ${DATE}"
        echo ""
        echo "**Generated:** $(date '+%Y-%m-%d %H:%M:%S')"
        echo "**Checked by:** ${SCRIPT_NAME}"
        echo ""
        echo "---"
        echo ""
        
        # Find all files to check
        local files_checked=0
        
        while IFS= read -r -d '' file; do
            ((files_checked++))
            
            local relative_path="${file#$REPO_ROOT/}"
            local file_violations
            
            if ! file_violations=$(check_file "$file" 2>/dev/null); then
                files_with_violations+=("$relative_path")
                ((total_violations++))
                
                echo "## ${relative_path}"
                echo ""
                echo "\`\`\`"
                echo -e "$file_violations"
                echo "\`\`\`"
                echo ""
            fi
        done < <(find "$REPO_ROOT" -type f \
            $(build_include_args | sed 's/-o/ -o /g') \
            -not -path "*/.git/*" \
            -not -path "*/node_modules/*" \
            -not -path "*/archive/*" \
            -print0 2>/dev/null)
        
        echo "---"
        echo ""
        echo "## Summary"
        echo ""
        echo "- **Files checked:** ${files_checked}"
        echo "- **Files with violations:** ${#files_with_violations[@]}"
        echo "- **Total violations:** ${total_violations}"
        echo ""
        
        if [[ $total_violations -eq 0 ]]; then
            echo "✅ **No violations found!**"
        else
            echo "⚠️ **Action required:** Review and fix violations above"
        fi
        
        echo ""
        echo "*Auto-generated by ${SCRIPT_NAME}*"
        
    } > "$REPORT_FILE"
    
    echo "$total_violations"
}

# Quick check (no report file)
quick_check() {
    local found_violations=0
    
    log_info "Running quick name violation check..."
    
    while IFS= read -r -d '' file; do
        local relative_path="${file#$REPO_ROOT/}"
        
        if ! check_file "$file" >/dev/null 2>&1; then
            log_warn "Violation found: ${relative_path}"
            found_violations=1
        fi
    done < <(find "$REPO_ROOT" -type f \
        $(build_include_args | sed 's/-o/ -o /g') \
        -not -path "*/.git/*" \
        -not -path "*/node_modules/*" \
        -not -path "*/archive/*" \
        -print0 2>/dev/null | head -z -n 100)
    
    if [[ $found_violations -eq 0 ]]; then
        log_success "No violations found in sample"
    else
        log_warn "Run with --report for full details"
    fi
    
    return $found_violations
}

# Show help
show_help() {
    cat << EOF
Usage: $SCRIPT_NAME [OPTIONS]

Automated check for name/policy violations in codebase.

Options:
  --report      Generate detailed markdown report
  --quick       Quick check (default, checks sample of files)
  --help, -h    Show this help

Examples:
  $SCRIPT_NAME              # Quick check
  $SCRIPT_NAME --report     # Generate full report

Reports are saved to: memory/alerts/name-violations-YYYY-MM-DD.md
EOF
}

# Main logic
main() {
    local mode="quick"
    
    # Parse arguments
    while [[ $# -gt 0 ]]; do
        case $1 in
            --report)
                mode="report"
                shift
                ;;
            --quick)
                mode="quick"
                shift
                ;;
            --help|-h)
                show_help
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                show_help
                exit 1
                ;;
        esac
    done
    
    cd "$REPO_ROOT"
    
    if [[ "$mode" == "report" ]]; then
        log_info "Generating full violation report..."
        local violations
        violations=$(generate_report)
        
        if [[ $violations -eq 0 ]]; then
            log_success "No violations found! Report: ${REPORT_FILE}"
        else
            log_warn "Found ${violations} violations. Report: ${REPORT_FILE}"
        fi
    else
        quick_check
    fi
}

# Run main
main "$@"
